/**
 * Reputation System for P2P Mining Pool
 * Manages node trustworthiness and incentive mechanisms
 */

import { EventEmitter } from 'events';
import { createHash } from 'crypto';
import { Logger } from '../logger.js';\n\n// Reputation events and their impacts\nexport const ReputationEvent = {\n  SHARE_VALID: { impact: 0.01, category: 'mining' },\n  SHARE_INVALID: { impact: -0.05, category: 'mining' },\n  SHARE_STALE: { impact: -0.01, category: 'mining' },\n  BLOCK_FOUND: { impact: 0.1, category: 'mining' },\n  \n  MESSAGE_RELAY: { impact: 0.005, category: 'network' },\n  MESSAGE_DROP: { impact: -0.02, category: 'network' },\n  PROTOCOL_VIOLATION: { impact: -0.1, category: 'network' },\n  \n  UPTIME_GOOD: { impact: 0.002, category: 'reliability' },\n  UPTIME_POOR: { impact: -0.01, category: 'reliability' },\n  RESPONSE_FAST: { impact: 0.001, category: 'reliability' },\n  RESPONSE_SLOW: { impact: -0.005, category: 'reliability' },\n  \n  VERIFICATION_CORRECT: { impact: 0.01, category: 'trust' },\n  VERIFICATION_INCORRECT: { impact: -0.1, category: 'trust' },\n  CONSENSUS_AGREEMENT: { impact: 0.005, category: 'trust' },\n  CONSENSUS_DISAGREEMENT: { impact: -0.02, category: 'trust' },\n  \n  HELP_NEWBIE: { impact: 0.02, category: 'community' },\n  SPAM_BEHAVIOR: { impact: -0.1, category: 'community' },\n  RESOURCE_SHARING: { impact: 0.01, category: 'community' }\n};\n\n// Reputation thresholds\nexport const ReputationThreshold = {\n  EXCELLENT: 0.9,\n  GOOD: 0.7,\n  AVERAGE: 0.5,\n  POOR: 0.3,\n  BANNED: 0.1\n};\n\n// Reputation decay parameters\nconst DECAY_RATE = 0.001; // Daily decay rate\nconst DECAY_INTERVAL = 86400000; // 24 hours\n\nexport class ReputationSystem extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.logger = options.logger || new Logger('ReputationSystem');\n    this.options = {\n      initialReputation: options.initialReputation || 0.5,\n      maxReputation: options.maxReputation || 1.0,\n      minReputation: options.minReputation || 0.0,\n      decayEnabled: options.decayEnabled !== false,\n      witnessRequired: options.witnessRequired !== false,\n      minWitnesses: options.minWitnesses || 3,\n      consensusThreshold: options.consensusThreshold || 0.6,\n      banThreshold: options.banThreshold || ReputationThreshold.BANNED,\n      ...options\n    };\n    \n    // Reputation storage\n    this.nodeReputations = new Map();\n    this.reputationHistory = new Map();\n    this.witnesses = new Map();\n    this.bannedNodes = new Set();\n    \n    // Event tracking\n    this.eventLog = [];\n    this.pendingEvents = new Map();\n    \n    // Statistics\n    this.stats = {\n      totalNodes: 0,\n      averageReputation: 0,\n      reputationDistribution: {},\n      eventsProcessed: 0,\n      consensusVotes: 0,\n      bannedCount: 0\n    };\n    \n    // Start background processes\n    this.startDecayProcess();\n    this.startConsensusProcess();\n    this.startStatisticsUpdate();\n  }\n  \n  /**\n   * Initialize reputation for a new node\n   */\n  initializeNode(nodeId, nodeInfo = {}) {\n    if (this.nodeReputations.has(nodeId)) {\n      return this.nodeReputations.get(nodeId);\n    }\n    \n    const reputation = {\n      nodeId,\n      score: this.options.initialReputation,\n      lastUpdate: Date.now(),\n      \n      // Category-specific scores\n      categories: {\n        mining: this.options.initialReputation,\n        network: this.options.initialReputation,\n        reliability: this.options.initialReputation,\n        trust: this.options.initialReputation,\n        community: this.options.initialReputation\n      },\n      \n      // Event counters\n      events: {\n        total: 0,\n        positive: 0,\n        negative: 0,\n        lastEvent: null\n      },\n      \n      // Behavioral metrics\n      behavior: {\n        responsiveness: 1.0,\n        consistency: 1.0,\n        helpfulness: 1.0,\n        trustworthiness: 1.0\n      },\n      \n      // Witness system\n      witnesses: new Set(),\n      witnessedBy: new Set(),\n      \n      // Metadata\n      nodeInfo,\n      createdAt: Date.now(),\n      isBanned: false\n    };\n    \n    this.nodeReputations.set(nodeId, reputation);\n    this.reputationHistory.set(nodeId, []);\n    this.stats.totalNodes++;\n    \n    this.logger.info(`Initialized reputation for node: ${nodeId}`);\n    this.emit('reputation:initialized', { nodeId, reputation });\n    \n    return reputation;\n  }\n  \n  /**\n   * Record reputation event\n   */\n  async recordEvent(nodeId, eventType, evidence = {}, witnesses = []) {\n    const reputation = this.nodeReputations.get(nodeId);\n    if (!reputation) {\n      throw new Error(`Node reputation not found: ${nodeId}`);\n    }\n    \n    if (reputation.isBanned) {\n      this.logger.warn(`Event ignored for banned node: ${nodeId}`);\n      return;\n    }\n    \n    const event = {\n      nodeId,\n      type: eventType,\n      evidence,\n      witnesses,\n      timestamp: Date.now(),\n      processed: false,\n      consensusRequired: this.options.witnessRequired && witnesses.length > 0\n    };\n    \n    // If consensus required, add to pending events\n    if (event.consensusRequired) {\n      const eventId = this.generateEventId(event);\n      this.pendingEvents.set(eventId, event);\n      \n      // Start consensus process\n      await this.startConsensusVoting(eventId, event);\n    } else {\n      // Process immediately\n      await this.processEvent(event);\n    }\n  }\n  \n  /**\n   * Process reputation event\n   */\n  async processEvent(event) {\n    const { nodeId, type, evidence, witnesses, timestamp } = event;\n    const reputation = this.nodeReputations.get(nodeId);\n    \n    if (!reputation) return;\n    \n    const eventDef = ReputationEvent[type];\n    if (!eventDef) {\n      this.logger.warn(`Unknown event type: ${type}`);\n      return;\n    }\n    \n    // Calculate impact\n    const impact = this.calculateEventImpact(eventDef, reputation, evidence);\n    \n    // Update reputation\n    const oldScore = reputation.score;\n    reputation.score = Math.max(\n      this.options.minReputation,\n      Math.min(this.options.maxReputation, reputation.score + impact)\n    );\n    \n    // Update category-specific score\n    if (eventDef.category) {\n      reputation.categories[eventDef.category] = Math.max(\n        this.options.minReputation,\n        Math.min(this.options.maxReputation, \n          reputation.categories[eventDef.category] + impact)\n      );\n    }\n    \n    // Update event counters\n    reputation.events.total++;\n    reputation.events.lastEvent = timestamp;\n    \n    if (impact > 0) {\n      reputation.events.positive++;\n    } else if (impact < 0) {\n      reputation.events.negative++;\n    }\n    \n    // Update behavioral metrics\n    this.updateBehavioralMetrics(reputation, type, evidence);\n    \n    // Record in history\n    const historyEntry = {\n      timestamp,\n      type,\n      oldScore,\n      newScore: reputation.score,\n      impact,\n      evidence,\n      witnesses\n    };\n    \n    const history = this.reputationHistory.get(nodeId);\n    history.push(historyEntry);\n    \n    // Keep only recent history\n    if (history.length > 1000) {\n      history.shift();\n    }\n    \n    reputation.lastUpdate = timestamp;\n    this.stats.eventsProcessed++;\n    \n    // Check for ban\n    if (reputation.score <= this.options.banThreshold) {\n      this.banNode(nodeId);\n    }\n    \n    event.processed = true;\n    \n    this.emit('reputation:updated', {\n      nodeId,\n      oldScore,\n      newScore: reputation.score,\n      impact,\n      event: type\n    });\n    \n    this.logger.debug(`Reputation updated for ${nodeId}: ${oldScore.toFixed(3)} â†’ ${reputation.score.toFixed(3)} (${impact > 0 ? '+' : ''}${impact.toFixed(3)})`);\n  }\n  \n  /**\n   * Calculate event impact\n   */\n  calculateEventImpact(eventDef, reputation, evidence) {\n    let impact = eventDef.impact;\n    \n    // Adjust based on current reputation\n    // Lower reputation nodes get bigger positive impacts\n    // Higher reputation nodes get bigger negative impacts\n    if (impact > 0) {\n      impact *= (1 - reputation.score) * 2 + 0.5;\n    } else {\n      impact *= reputation.score * 2 + 0.5;\n    }\n    \n    // Adjust based on evidence quality\n    if (evidence.confidence) {\n      impact *= evidence.confidence;\n    }\n    \n    // Adjust based on severity\n    if (evidence.severity) {\n      impact *= evidence.severity;\n    }\n    \n    return impact;\n  }\n  \n  /**\n   * Update behavioral metrics\n   */\n  updateBehavioralMetrics(reputation, eventType, evidence) {\n    const alpha = 0.1; // Learning rate\n    \n    switch (eventType) {\n      case 'RESPONSE_FAST':\n        reputation.behavior.responsiveness = \n          (1 - alpha) * reputation.behavior.responsiveness + alpha * 1.0;\n        break;\n        \n      case 'RESPONSE_SLOW':\n        reputation.behavior.responsiveness = \n          (1 - alpha) * reputation.behavior.responsiveness + alpha * 0.5;\n        break;\n        \n      case 'VERIFICATION_CORRECT':\n        reputation.behavior.trustworthiness = \n          (1 - alpha) * reputation.behavior.trustworthiness + alpha * 1.0;\n        break;\n        \n      case 'VERIFICATION_INCORRECT':\n        reputation.behavior.trustworthiness = \n          (1 - alpha) * reputation.behavior.trustworthiness + alpha * 0.0;\n        break;\n        \n      case 'HELP_NEWBIE':\n        reputation.behavior.helpfulness = \n          (1 - alpha) * reputation.behavior.helpfulness + alpha * 1.0;\n        break;\n        \n      case 'SPAM_BEHAVIOR':\n        reputation.behavior.helpfulness = \n          (1 - alpha) * reputation.behavior.helpfulness + alpha * 0.0;\n        break;\n    }\n    \n    // Update consistency based on variance in behavior\n    const behaviors = Object.values(reputation.behavior);\n    const variance = this.calculateVariance(behaviors);\n    reputation.behavior.consistency = Math.max(0, 1 - variance);\n  }\n  \n  /**\n   * Start consensus voting for event\n   */\n  async startConsensusVoting(eventId, event) {\n    const { witnesses } = event;\n    \n    if (witnesses.length < this.options.minWitnesses) {\n      this.logger.warn(`Insufficient witnesses for event: ${eventId}`);\n      return;\n    }\n    \n    const votes = new Map();\n    const votePromises = witnesses.map(witnessId => \n      this.requestVote(witnessId, eventId, event)\n    );\n    \n    const results = await Promise.allSettled(votePromises);\n    \n    // Collect votes\n    results.forEach((result, index) => {\n      if (result.status === 'fulfilled') {\n        votes.set(witnesses[index], result.value);\n      }\n    });\n    \n    // Process consensus\n    const consensus = this.processConsensus(votes);\n    \n    if (consensus.reached) {\n      // Apply consensus result\n      event.consensusResult = consensus;\n      await this.processEvent(event);\n      \n      // Update witness reputations\n      this.updateWitnessReputations(witnesses, votes, consensus);\n    }\n    \n    this.pendingEvents.delete(eventId);\n    this.stats.consensusVotes++;\n  }\n  \n  /**\n   * Request vote from witness\n   */\n  async requestVote(witnessId, eventId, event) {\n    // In production, send actual network request\n    // For now, simulate witness voting\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        const witnessRep = this.nodeReputations.get(witnessId);\n        const reliability = witnessRep ? witnessRep.behavior.trustworthiness : 0.5;\n        \n        // Simulate vote based on witness reliability\n        const vote = {\n          agree: Math.random() < reliability,\n          confidence: 0.5 + Math.random() * 0.5,\n          timestamp: Date.now()\n        };\n        \n        resolve(vote);\n      }, 100 + Math.random() * 500);\n    });\n  }\n  \n  /**\n   * Process consensus votes\n   */\n  processConsensus(votes) {\n    const totalVotes = votes.size;\n    const agreeVotes = Array.from(votes.values()).filter(v => v.agree).length;\n    const consensusRatio = agreeVotes / totalVotes;\n    \n    return {\n      reached: consensusRatio >= this.options.consensusThreshold,\n      ratio: consensusRatio,\n      totalVotes,\n      agreeVotes,\n      timestamp: Date.now()\n    };\n  }\n  \n  /**\n   * Update witness reputations based on consensus\n   */\n  updateWitnessReputations(witnesses, votes, consensus) {\n    for (const witnessId of witnesses) {\n      const vote = votes.get(witnessId);\n      if (!vote) continue;\n      \n      const agreedWithConsensus = \n        (vote.agree && consensus.reached) || \n        (!vote.agree && !consensus.reached);\n      \n      // Update witness reputation\n      const eventType = agreedWithConsensus ? \n        'CONSENSUS_AGREEMENT' : 'CONSENSUS_DISAGREEMENT';\n      \n      this.processEvent({\n        nodeId: witnessId,\n        type: eventType,\n        evidence: { confidence: vote.confidence },\n        witnesses: [],\n        timestamp: Date.now(),\n        processed: false,\n        consensusRequired: false\n      });\n    }\n  }\n  \n  /**\n   * Ban node\n   */\n  banNode(nodeId) {\n    const reputation = this.nodeReputations.get(nodeId);\n    if (!reputation) return;\n    \n    reputation.isBanned = true;\n    this.bannedNodes.add(nodeId);\n    this.stats.bannedCount++;\n    \n    this.logger.warn(`Node banned: ${nodeId} (reputation: ${reputation.score.toFixed(3)})`);\n    this.emit('node:banned', { nodeId, reputation: reputation.score });\n  }\n  \n  /**\n   * Unban node (administrative)\n   */\n  unbanNode(nodeId) {\n    const reputation = this.nodeReputations.get(nodeId);\n    if (!reputation) return;\n    \n    reputation.isBanned = false;\n    reputation.score = this.options.initialReputation;\n    this.bannedNodes.delete(nodeId);\n    this.stats.bannedCount--;\n    \n    this.logger.info(`Node unbanned: ${nodeId}`);\n    this.emit('node:unbanned', { nodeId });\n  }\n  \n  /**\n   * Get node reputation\n   */\n  getReputation(nodeId) {\n    return this.nodeReputations.get(nodeId);\n  }\n  \n  /**\n   * Get top nodes by reputation\n   */\n  getTopNodes(limit = 10) {\n    const nodes = Array.from(this.nodeReputations.values())\n      .filter(rep => !rep.isBanned)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, limit);\n    \n    return nodes;\n  }\n  \n  /**\n   * Get nodes by reputation threshold\n   */\n  getNodesByThreshold(threshold) {\n    return Array.from(this.nodeReputations.values())\n      .filter(rep => !rep.isBanned && rep.score >= threshold)\n      .sort((a, b) => b.score - a.score);\n  }\n  \n  /**\n   * Start decay process\n   */\n  startDecayProcess() {\n    if (!this.options.decayEnabled) return;\n    \n    setInterval(() => {\n      this.applyDecay();\n    }, DECAY_INTERVAL);\n  }\n  \n  /**\n   * Apply reputation decay\n   */\n  applyDecay() {\n    const now = Date.now();\n    \n    for (const [nodeId, reputation] of this.nodeReputations) {\n      if (reputation.isBanned) continue;\n      \n      // Apply decay based on time since last update\n      const timeSinceUpdate = now - reputation.lastUpdate;\n      const decayFactor = (timeSinceUpdate / DECAY_INTERVAL) * DECAY_RATE;\n      \n      // Decay towards initial reputation\n      const target = this.options.initialReputation;\n      const decay = (reputation.score - target) * decayFactor;\n      \n      reputation.score = Math.max(\n        this.options.minReputation,\n        Math.min(this.options.maxReputation, reputation.score - decay)\n      );\n      \n      // Decay category scores\n      for (const [category, score] of Object.entries(reputation.categories)) {\n        const categoryDecay = (score - target) * decayFactor;\n        reputation.categories[category] = Math.max(\n          this.options.minReputation,\n          Math.min(this.options.maxReputation, score - categoryDecay)\n        );\n      }\n    }\n    \n    this.logger.debug('Applied reputation decay');\n  }\n  \n  /**\n   * Start consensus process\n   */\n  startConsensusProcess() {\n    setInterval(() => {\n      this.processExpiredEvents();\n    }, 60000); // Every minute\n  }\n  \n  /**\n   * Process expired consensus events\n   */\n  processExpiredEvents() {\n    const now = Date.now();\n    const expiredThreshold = 300000; // 5 minutes\n    \n    for (const [eventId, event] of this.pendingEvents) {\n      if (now - event.timestamp > expiredThreshold) {\n        this.logger.warn(`Consensus event expired: ${eventId}`);\n        this.pendingEvents.delete(eventId);\n      }\n    }\n  }\n  \n  /**\n   * Start statistics update\n   */\n  startStatisticsUpdate() {\n    setInterval(() => {\n      this.updateStatistics();\n    }, 60000); // Every minute\n  }\n  \n  /**\n   * Update statistics\n   */\n  updateStatistics() {\n    const activeNodes = Array.from(this.nodeReputations.values())\n      .filter(rep => !rep.isBanned);\n    \n    // Calculate average reputation\n    this.stats.averageReputation = activeNodes.length > 0 \n      ? activeNodes.reduce((sum, rep) => sum + rep.score, 0) / activeNodes.length\n      : 0;\n    \n    // Calculate reputation distribution\n    this.stats.reputationDistribution = {\n      excellent: activeNodes.filter(rep => rep.score >= ReputationThreshold.EXCELLENT).length,\n      good: activeNodes.filter(rep => rep.score >= ReputationThreshold.GOOD && rep.score < ReputationThreshold.EXCELLENT).length,\n      average: activeNodes.filter(rep => rep.score >= ReputationThreshold.AVERAGE && rep.score < ReputationThreshold.GOOD).length,\n      poor: activeNodes.filter(rep => rep.score >= ReputationThreshold.POOR && rep.score < ReputationThreshold.AVERAGE).length,\n      banned: this.bannedNodes.size\n    };\n    \n    this.emit('statistics:updated', this.stats);\n  }\n  \n  /**\n   * Helper methods\n   */\n  \n  generateEventId(event) {\n    return createHash('sha256')\n      .update(JSON.stringify(event))\n      .digest('hex')\n      .substring(0, 16);\n  }\n  \n  calculateVariance(values) {\n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n    return variance;\n  }\n  \n  /**\n   * Get reputation statistics\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      pendingEvents: this.pendingEvents.size,\n      totalHistory: Array.from(this.reputationHistory.values())\n        .reduce((sum, history) => sum + history.length, 0)\n    };\n  }\n  \n  /**\n   * Export reputation data\n   */\n  exportReputations() {\n    const data = {\n      timestamp: Date.now(),\n      nodeReputations: Object.fromEntries(this.nodeReputations),\n      bannedNodes: Array.from(this.bannedNodes),\n      stats: this.stats\n    };\n    \n    return JSON.stringify(data, null, 2);\n  }\n  \n  /**\n   * Import reputation data\n   */\n  importReputations(data) {\n    const parsed = JSON.parse(data);\n    \n    this.nodeReputations.clear();\n    this.bannedNodes.clear();\n    \n    for (const [nodeId, reputation] of Object.entries(parsed.nodeReputations)) {\n      this.nodeReputations.set(nodeId, reputation);\n    }\n    \n    for (const nodeId of parsed.bannedNodes) {\n      this.bannedNodes.add(nodeId);\n    }\n    \n    this.stats = parsed.stats;\n    \n    this.logger.info('Reputation data imported');\n    this.emit('reputation:imported', { nodes: this.nodeReputations.size });\n  }\n}