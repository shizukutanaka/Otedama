/**
 * Cache Manager
 * Multi-tier caching system for optimal performance
 */

const EventEmitter = require('events');
const LRU = require('lru-cache');
const Redis = require('ioredis');

class CacheManager extends EventEmitter {
  constructor(options = {}) {
    super();
    
    this.config = {
      // Redis configuration
      redis: {
        enabled: options.redis?.enabled !== false,
        host: options.redis?.host || 'localhost',
        port: options.redis?.port || 6379,
        password: options.redis?.password,
        db: options.redis?.db || 0,
        keyPrefix: options.redis?.keyPrefix || 'otedama:cache:',
        ...options.redis
      },
      
      // Memory cache configuration
      memory: {
        max: options.memory?.max || 10000,
        ttl: options.memory?.ttl || 300000, // 5 minutes
        allowStale: options.memory?.allowStale !== false,
        updateAgeOnGet: options.memory?.updateAgeOnGet !== false,
        ...options.memory
      },
      
      // Performance settings
      compression: options.compression !== false,
      serialization: options.serialization || 'json',
      
      // Monitoring
      enableMetrics: options.enableMetrics !== false,
      metricsInterval: options.metricsInterval || 30000,
      
      ...options
    };
    
    // Cache tiers
    this.tiers = {
      memory: null,
      redis: null
    };
    
    // Metrics
    this.metrics = {
      hits: { memory: 0, redis: 0, total: 0 },
      misses: { memory: 0, redis: 0, total: 0 },
      sets: { memory: 0, redis: 0, total: 0 },
      deletes: { memory: 0, redis: 0, total: 0 },
      errors: { memory: 0, redis: 0, total: 0 },
      hitRate: 0,
      avgResponseTime: 0,
      memoryUsage: 0
    };
    
    // Performance tracking
    this.responseTimes = [];
    
    this.initialized = false;
  }
  
  /**
   * Initialize cache manager
   */\n  async initialize() {\n    if (this.initialized) return;\n    \n    try {\n      // Initialize memory cache\n      this.initializeMemoryCache();\n      \n      // Initialize Redis cache if enabled\n      if (this.config.redis.enabled) {\n        await this.initializeRedisCache();\n      }\n      \n      // Start monitoring\n      if (this.config.enableMetrics) {\n        this.startMetricsCollection();\n      }\n      \n      this.initialized = true;\n      this.emit('initialized');\n      \n      console.log('Cache manager initialized successfully');\n      \n    } catch (error) {\n      console.error('Failed to initialize cache manager:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Initialize memory cache (LRU)\n   */\n  initializeMemoryCache() {\n    this.tiers.memory = new LRU({\n      max: this.config.memory.max,\n      ttl: this.config.memory.ttl,\n      allowStale: this.config.memory.allowStale,\n      updateAgeOnGet: this.config.memory.updateAgeOnGet,\n      updateAgeOnHas: this.config.memory.updateAgeOnHas\n    });\n    \n    // Set up memory cache events\n    this.tiers.memory.on('evict', (key, value) => {\n      this.emit('memory:evict', { key, value });\n    });\n    \n    console.log('Memory cache initialized');\n  }\n  \n  /**\n   * Initialize Redis cache\n   */\n  async initializeRedisCache() {\n    try {\n      // Create Redis cluster or single instance\n      if (this.config.redis.cluster) {\n        this.tiers.redis = new Redis.Cluster(this.config.redis.cluster, {\n          redisOptions: {\n            password: this.config.redis.password,\n            keyPrefix: this.config.redis.keyPrefix,\n            ...this.config.redis.options\n          },\n          ...this.config.redis.clusterOptions\n        });\n      } else {\n        this.tiers.redis = new Redis({\n          host: this.config.redis.host,\n          port: this.config.redis.port,\n          password: this.config.redis.password,\n          db: this.config.redis.db,\n          keyPrefix: this.config.redis.keyPrefix,\n          retryDelayOnFailover: 100,\n          maxRetriesPerRequest: 3,\n          lazyConnect: true,\n          ...this.config.redis.options\n        });\n      }\n      \n      // Set up Redis events\n      this.tiers.redis.on('connect', () => {\n        console.log('Redis cache connected');\n        this.emit('redis:connected');\n      });\n      \n      this.tiers.redis.on('error', (error) => {\n        console.error('Redis cache error:', error);\n        this.metrics.errors.redis++;\n        this.emit('redis:error', error);\n      });\n      \n      this.tiers.redis.on('close', () => {\n        console.warn('Redis cache connection closed');\n        this.emit('redis:disconnected');\n      });\n      \n      // Test connection\n      await this.tiers.redis.ping();\n      \n    } catch (error) {\n      console.error('Failed to initialize Redis cache:', error);\n      \n      // Disable Redis if connection fails\n      this.config.redis.enabled = false;\n      this.tiers.redis = null;\n      \n      if (this.config.redis.required) {\n        throw error;\n      }\n    }\n  }\n  \n  /**\n   * Get value from cache with multi-tier lookup\n   */\n  async get(key, options = {}) {\n    const startTime = Date.now();\n    \n    try {\n      // Try memory cache first\n      let value = this.tiers.memory?.get(key);\n      if (value !== undefined) {\n        this.metrics.hits.memory++;\n        this.metrics.hits.total++;\n        this.recordResponseTime(Date.now() - startTime);\n        return this.deserialize(value);\n      }\n      \n      this.metrics.misses.memory++;\n      \n      // Try Redis cache\n      if (this.tiers.redis && this.config.redis.enabled) {\n        try {\n          const redisValue = await this.tiers.redis.get(key);\n          if (redisValue !== null) {\n            this.metrics.hits.redis++;\n            this.metrics.hits.total++;\n            \n            // Promote to memory cache\n            const deserializedValue = this.deserialize(redisValue);\n            this.tiers.memory?.set(key, this.serialize(deserializedValue), {\n              ttl: options.ttl || this.config.memory.ttl\n            });\n            \n            this.recordResponseTime(Date.now() - startTime);\n            return deserializedValue;\n          }\n        } catch (error) {\n          console.error(`Redis get error for key ${key}:`, error);\n          this.metrics.errors.redis++;\n        }\n      }\n      \n      this.metrics.misses.redis++;\n      this.metrics.misses.total++;\n      this.recordResponseTime(Date.now() - startTime);\n      \n      return undefined;\n      \n    } catch (error) {\n      console.error(`Cache get error for key ${key}:`, error);\n      this.metrics.errors.total++;\n      this.recordResponseTime(Date.now() - startTime);\n      throw error;\n    }\n  }\n  \n  /**\n   * Set value in cache with multi-tier storage\n   */\n  async set(key, value, options = {}) {\n    const startTime = Date.now();\n    \n    try {\n      const serializedValue = this.serialize(value);\n      const ttl = options.ttl || this.config.memory.ttl;\n      \n      // Store in memory cache\n      if (this.tiers.memory) {\n        this.tiers.memory.set(key, serializedValue, { ttl });\n        this.metrics.sets.memory++;\n      }\n      \n      // Store in Redis cache\n      if (this.tiers.redis && this.config.redis.enabled) {\n        try {\n          if (ttl) {\n            await this.tiers.redis.setex(key, Math.floor(ttl / 1000), serializedValue);\n          } else {\n            await this.tiers.redis.set(key, serializedValue);\n          }\n          this.metrics.sets.redis++;\n        } catch (error) {\n          console.error(`Redis set error for key ${key}:`, error);\n          this.metrics.errors.redis++;\n        }\n      }\n      \n      this.metrics.sets.total++;\n      this.recordResponseTime(Date.now() - startTime);\n      \n      return true;\n      \n    } catch (error) {\n      console.error(`Cache set error for key ${key}:`, error);\n      this.metrics.errors.total++;\n      this.recordResponseTime(Date.now() - startTime);\n      throw error;\n    }\n  }\n  \n  /**\n   * Delete value from cache\n   */\n  async delete(key) {\n    const startTime = Date.now();\n    \n    try {\n      let deleted = false;\n      \n      // Delete from memory cache\n      if (this.tiers.memory) {\n        deleted = this.tiers.memory.delete(key) || deleted;\n        this.metrics.deletes.memory++;\n      }\n      \n      // Delete from Redis cache\n      if (this.tiers.redis && this.config.redis.enabled) {\n        try {\n          const result = await this.tiers.redis.del(key);\n          deleted = result > 0 || deleted;\n          this.metrics.deletes.redis++;\n        } catch (error) {\n          console.error(`Redis delete error for key ${key}:`, error);\n          this.metrics.errors.redis++;\n        }\n      }\n      \n      this.metrics.deletes.total++;\n      this.recordResponseTime(Date.now() - startTime);\n      \n      return deleted;\n      \n    } catch (error) {\n      console.error(`Cache delete error for key ${key}:`, error);\n      this.metrics.errors.total++;\n      this.recordResponseTime(Date.now() - startTime);\n      throw error;\n    }\n  }\n  \n  /**\n   * Check if key exists in cache\n   */\n  async has(key) {\n    try {\n      // Check memory cache first\n      if (this.tiers.memory?.has(key)) {\n        return true;\n      }\n      \n      // Check Redis cache\n      if (this.tiers.redis && this.config.redis.enabled) {\n        try {\n          const exists = await this.tiers.redis.exists(key);\n          return exists === 1;\n        } catch (error) {\n          console.error(`Redis exists error for key ${key}:`, error);\n          this.metrics.errors.redis++;\n        }\n      }\n      \n      return false;\n      \n    } catch (error) {\n      console.error(`Cache has error for key ${key}:`, error);\n      this.metrics.errors.total++;\n      return false;\n    }\n  }\n  \n  /**\n   * Get multiple values at once\n   */\n  async mget(keys) {\n    const results = new Map();\n    const missingKeys = [];\n    \n    // Check memory cache first\n    for (const key of keys) {\n      const value = this.tiers.memory?.get(key);\n      if (value !== undefined) {\n        results.set(key, this.deserialize(value));\n        this.metrics.hits.memory++;\n      } else {\n        missingKeys.push(key);\n        this.metrics.misses.memory++;\n      }\n    }\n    \n    // Check Redis for missing keys\n    if (missingKeys.length > 0 && this.tiers.redis && this.config.redis.enabled) {\n      try {\n        const redisResults = await this.tiers.redis.mget(missingKeys);\n        \n        for (let i = 0; i < missingKeys.length; i++) {\n          const key = missingKeys[i];\n          const value = redisResults[i];\n          \n          if (value !== null) {\n            const deserializedValue = this.deserialize(value);\n            results.set(key, deserializedValue);\n            \n            // Promote to memory cache\n            this.tiers.memory?.set(key, this.serialize(deserializedValue));\n            \n            this.metrics.hits.redis++;\n          } else {\n            this.metrics.misses.redis++;\n          }\n        }\n      } catch (error) {\n        console.error('Redis mget error:', error);\n        this.metrics.errors.redis++;\n      }\n    }\n    \n    this.metrics.hits.total += results.size;\n    this.metrics.misses.total += keys.length - results.size;\n    \n    return results;\n  }\n  \n  /**\n   * Set multiple values at once\n   */\n  async mset(entries, options = {}) {\n    const promises = [];\n    \n    for (const [key, value] of entries) {\n      promises.push(this.set(key, value, options));\n    }\n    \n    await Promise.all(promises);\n    return true;\n  }\n  \n  /**\n   * Clear all cache data\n   */\n  async clear() {\n    try {\n      // Clear memory cache\n      if (this.tiers.memory) {\n        this.tiers.memory.clear();\n      }\n      \n      // Clear Redis cache with prefix\n      if (this.tiers.redis && this.config.redis.enabled) {\n        try {\n          const pattern = this.config.redis.keyPrefix + '*';\n          const keys = await this.tiers.redis.keys(pattern);\n          \n          if (keys.length > 0) {\n            await this.tiers.redis.del(keys);\n          }\n        } catch (error) {\n          console.error('Redis clear error:', error);\n          this.metrics.errors.redis++;\n        }\n      }\n      \n      return true;\n      \n    } catch (error) {\n      console.error('Cache clear error:', error);\n      this.metrics.errors.total++;\n      throw error;\n    }\n  }\n  \n  /**\n   * Serialize value for storage\n   */\n  serialize(value) {\n    try {\n      if (this.config.serialization === 'json') {\n        return JSON.stringify(value);\n      } else if (this.config.serialization === 'msgpack') {\n        // Implement MessagePack serialization if needed\n        return JSON.stringify(value);\n      }\n      \n      return String(value);\n      \n    } catch (error) {\n      console.error('Serialization error:', error);\n      return String(value);\n    }\n  }\n  \n  /**\n   * Deserialize value from storage\n   */\n  deserialize(value) {\n    try {\n      if (this.config.serialization === 'json') {\n        return JSON.parse(value);\n      } else if (this.config.serialization === 'msgpack') {\n        // Implement MessagePack deserialization if needed\n        return JSON.parse(value);\n      }\n      \n      return value;\n      \n    } catch (error) {\n      console.error('Deserialization error:', error);\n      return value;\n    }\n  }\n  \n  /**\n   * Record response time for metrics\n   */\n  recordResponseTime(time) {\n    this.responseTimes.push(time);\n    \n    // Keep only recent response times\n    if (this.responseTimes.length > 1000) {\n      this.responseTimes = this.responseTimes.slice(-1000);\n    }\n    \n    // Update average\n    const sum = this.responseTimes.reduce((a, b) => a + b, 0);\n    this.metrics.avgResponseTime = sum / this.responseTimes.length;\n  }\n  \n  /**\n   * Start metrics collection\n   */\n  startMetricsCollection() {\n    setInterval(() => {\n      this.updateMetrics();\n      this.emit('metrics', this.getMetrics());\n    }, this.config.metricsInterval);\n  }\n  \n  /**\n   * Update metrics\n   */\n  updateMetrics() {\n    // Calculate hit rate\n    const totalOperations = this.metrics.hits.total + this.metrics.misses.total;\n    this.metrics.hitRate = totalOperations > 0 ? this.metrics.hits.total / totalOperations : 0;\n    \n    // Update memory usage\n    if (this.tiers.memory) {\n      this.metrics.memoryUsage = this.tiers.memory.size;\n    }\n  }\n  \n  /**\n   * Get cache metrics\n   */\n  getMetrics() {\n    return {\n      ...this.metrics,\n      tiers: {\n        memory: {\n          enabled: !!this.tiers.memory,\n          size: this.tiers.memory?.size || 0,\n          max: this.config.memory.max\n        },\n        redis: {\n          enabled: this.config.redis.enabled && !!this.tiers.redis,\n          connected: this.tiers.redis?.status === 'ready'\n        }\n      }\n    };\n  }\n  \n  /**\n   * Get cache status\n   */\n  getStatus() {\n    return {\n      initialized: this.initialized,\n      tiers: {\n        memory: {\n          enabled: !!this.tiers.memory,\n          size: this.tiers.memory?.size || 0,\n          maxSize: this.config.memory.max\n        },\n        redis: {\n          enabled: this.config.redis.enabled,\n          connected: this.tiers.redis?.status === 'ready',\n          status: this.tiers.redis?.status || 'disconnected'\n        }\n      },\n      metrics: this.getMetrics()\n    };\n  }\n  \n  /**\n   * Flush stale entries\n   */\n  flush() {\n    if (this.tiers.memory) {\n      this.tiers.memory.purgeStale();\n    }\n  }\n  \n  /**\n   * Shutdown cache manager\n   */\n  async shutdown() {\n    console.log('Shutting down cache manager...');\n    \n    // Clear memory cache\n    if (this.tiers.memory) {\n      this.tiers.memory.clear();\n      this.tiers.memory = null;\n    }\n    \n    // Disconnect Redis\n    if (this.tiers.redis) {\n      await this.tiers.redis.quit();\n      this.tiers.redis = null;\n    }\n    \n    this.initialized = false;\n    this.emit('shutdown');\n  }\n}\n\nmodule.exports = CacheManager;"