/**
 * Webpack Plugin for Fee Configuration Protection
 * Ensures fee configuration cannot be modified during build process
 */

const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

class FeeProtectionPlugin {
  constructor(options = {}) {
    this.options = {
      configFile: options.configFile || 'lib/core/immutable-fee-config.js',
      expectedHash: options.expectedHash || null,
      failOnMismatch: options.failOnMismatch !== false,
      ...options
    };
    
    this.originalHash = null;
  }
  
  apply(compiler) {
    const pluginName = 'FeeProtectionPlugin';
    
    // Before compilation starts
    compiler.hooks.beforeCompile.tapAsync(pluginName, (params, callback) => {
      this.verifyFeeConfig(compiler.context)
        .then(() => callback())
        .catch(err => callback(err));
    });
    
    // After emit (before files are written)
    compiler.hooks.emit.tapAsync(pluginName, (compilation, callback) => {
      this.protectBuildOutput(compilation)
        .then(() => callback())
        .catch(err => callback(err));
    });
    
    // After done
    compiler.hooks.done.tap(pluginName, (stats) => {
      if (!stats.hasErrors()) {
        console.log('✅ Fee configuration protection applied successfully');
      }
    });
  }
  
  async verifyFeeConfig(context) {
    const configPath = path.join(context, this.options.configFile);
    
    if (!fs.existsSync(configPath)) {
      throw new Error(`Fee config file not found: ${configPath}`);
    }
    
    // Read and hash the config file
    const content = fs.readFileSync(configPath, 'utf8');
    this.originalHash = crypto.createHash('sha256').update(content).digest('hex');
    
    // Verify critical values are present
    const criticalPatterns = [
      /BASE_FEE:\s*0\.01/,
      /OPERATOR_ADDRESSES:/,
      /bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh/
    ];
    
    for (const pattern of criticalPatterns) {
      if (!pattern.test(content)) {
        throw new Error(`Critical fee configuration missing or modified! Pattern: ${pattern}`);
      }
    }
    
    // If expected hash is provided, verify it
    if (this.options.expectedHash && this.originalHash !== this.options.expectedHash) {
      const message = `Fee configuration hash mismatch!\nExpected: ${this.options.expectedHash}\nActual: ${this.originalHash}`;
      
      if (this.options.failOnMismatch) {
        throw new Error(message);
      } else {
        console.warn(`⚠️  ${message}`);
      }
    }
    
    console.log(`🔒 Fee configuration verified. Hash: ${this.originalHash}`);
  }
  
  async protectBuildOutput(compilation) {
    const assets = compilation.assets;
    
    // Find all JavaScript files
    const jsFiles = Object.keys(assets).filter(name => name.endsWith('.js'));
    
    for (const fileName of jsFiles) {
      const asset = assets[fileName];
      let source = asset.source();
      
      // Check if this file contains fee configuration
      if (source.includes('IMMUTABLE_CONFIG') || source.includes('immutable-fee-config')) {
        // Add runtime protection
        const protection = this.generateRuntimeProtection();
        
        // Inject protection code
        source = protection + '\n' + source;
        
        // Add integrity check
        source = source.replace(
          /module\.exports\s*=\s*Object\.freeze\(/g,
          `
// Runtime integrity check
(function() {
  const config = IMMUTABLE_CONFIG;
  if (config.POOL_FEES.BASE_FEE !== 0.01) {
    throw new Error('CRITICAL: Fee configuration tampering detected at runtime!');
  }
})();

module.exports = Object.freeze(`
        );
        
        // Update the asset
        compilation.assets[fileName] = {
          source: () => source,
          size: () => source.length
        };
        
        console.log(`🛡️  Protected fee configuration in: ${fileName}`);
      }
    }
  }
  
  generateRuntimeProtection() {
    return `
/**
 * Fee Configuration Runtime Protection
 * Auto-generated by FeeProtectionPlugin - DO NOT MODIFY
 */
(function() {
  'use strict';
  
  // Prevent debugging
  if (typeof window !== 'undefined') {
    // Disable right-click
    document.addEventListener('contextmenu', function(e) {
      if (e.target.toString().includes('fee') || e.target.toString().includes('IMMUTABLE')) {
        e.preventDefault();
        return false;
      }
    });
    
    // Detect dev tools
    let devtools = {open: false, orientation: null};
    const threshold = 160;
    setInterval(function() {
      if (window.outerHeight - window.innerHeight > threshold || 
          window.outerWidth - window.innerWidth > threshold) {
        if (!devtools.open) {
          devtools.open = true;
          console.warn('⚠️ Developer tools detected. Fee configuration is protected.');
        }
      } else {
        devtools.open = false;
      }
    }, 500);
  }
  
  // Freeze all fee-related objects
  const freezeDeep = (obj) => {
    Object.freeze(obj);
    Object.getOwnPropertyNames(obj).forEach(prop => {
      if (obj[prop] !== null && (typeof obj[prop] === 'object' || typeof obj[prop] === 'function')) {
        freezeDeep(obj[prop]);
      }
    });
    return obj;
  };
  
  // Apply deep freeze to any fee configuration objects
  if (typeof IMMUTABLE_CONFIG !== 'undefined') {
    freezeDeep(IMMUTABLE_CONFIG);
  }
})();
`;
  }
}

module.exports = FeeProtectionPlugin;